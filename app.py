from flask import Flask, render_template, request
import requests

app = Flask(__name__)

# XSS Payload
xss_payload = "<script>alert('XSS')</script>"

# SQL Injection Payload
sqli_payload = "' OR '1'='1"

@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        url = request.form['url']
        result_data = {
            "SQL Injection": [],
            "XSS": None
        }

        # Remove trailing slashes for consistent URL formatting
        if url.endswith('/'):
            url = url[:-1]

        # Testing SQL Injection
        try:
            sqli_test_url = f"{url}/vulnerabilities/sqli/?id={sqli_payload}"
            sqli_response = requests.get(sqli_test_url)

            # Check for common SQL errors in the response
            sql_errors = ["you have an error in your sql syntax", "warning: mysql", "unclosed quotation mark"]
            if any(error in sqli_response.text.lower() for error in sql_errors):
                result_data["SQL Injection"].append(sqli_test_url)  # Append the vulnerable URL
            # No else needed, keep it empty if no vulnerabilities found

        except Exception as e:
            result_data["SQL Injection"].append(f"Error: {str(e)}")

        # Testing XSS
        try:
            xss_test_url = f"{url}/vulnerabilities/xss_r/?name={requests.utils.quote(xss_payload)}"
            xss_response = requests.get(xss_test_url)

            # Check if the payload is reflected in the response
            if xss_payload in xss_response.text:
                result_data["XSS"] = xss_test_url  # Store the found XSS vulnerability
            # No else needed, keep it None if no vulnerabilities found

        except Exception as e:
            result_data["XSS"] = f"Error: {str(e)}"

        return render_template('result.html', url=url, results=result_data)

    return render_template('index.html')

if __name__ == '__main__':
    app.run(debug=True)
